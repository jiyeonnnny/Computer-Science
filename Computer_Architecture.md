## 1. 캐시메모리란
```
속도가 빠른 장치와 느린 장치 사이 속도 차이로 인한 병목 현상을 줄이기 위한 메모리를 캐시 메모리라고 함
1) CPU와 메모리 사이의 병목 현상 완화
2) 웹 브라우저 캐시 파일은, 하드디스크와 웹페이지 사이의 병목 현상을 완화
```
```
1) CPU와 메모리 사이의 병목 현상 완화

CPU는 주기억장치에 저장된 데이터를 읽어올때,
주기억장치는 속도가 너무 느리고,
CPU는 그에 비해 속도가 빨라서,
병목 현상이 생김.

이때 캐시 메모리를 활용해서, 자주 불러오는 데이터를 캐시메모리에 저장해서,
다음에 이용할때 주기억장치가 아닌 케시 메모리에서 가져오면,
데이터를 불러오는 속도가 향상되어서, 병목 현상을 완화할 수 있음

장점 : 병목 현상 완화
단점 : 캐시메모리는 가격이 매우매우 비싸서 메모리 크기가 작음 
```
```
L1, L2, L3 캐시 메모리

보통 CPU는 캐시 메모리가 2~3개 정도 됨. 이걸 각각 L1 L2 L3 캐시 메모리라 부름.
속도와 크기에 따라 분류하는데, 일반적으로 CPU는 L1 캐시를 먼저 사용함
CPU에서 가장 빠르게 접근 가능해서 그럼.
L1 캐시에서 데이터 못 찾으면 L2로 감.
```
```
듀얼 코어 프로세서의 캐시 메모리

각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장되어 있음.
만약 L1 캐시가 128kb면, 64/64로 나눠서 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고,
나머지 64kb에는 실행 후 명령어를 임시저장함
(명령어 세트로 구성 I-cache, D-cache)

L1 : CPU 내부에 존재
L2 : CPU와 RAM사이에 존재
L3 : 보통 메인 보드에 존재
```

<br>

## 2. 작동 원리
캐시 메모리에 어떤 걸 저장 해야하나?    
시간 지역성 : for이나 while같은 반복문에서 사용하는 조건 변수처럼, 한번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음   
공간 지역성 : A[0],A[1]같이 연속 접근 시, 참조된 데이터의 근처에 있는 데이터가 재사용될 가능성이 높음   

<br>

캐시에 데이터를 저장할때, 이런 공간 지역성(참조 지역성)을 최대한 활용하기 위해,
해당 데이터 뿐만 아니라, 옆 주소 데이터도 같이 캐시에 저장해서, 미래에 쓰일 것을 대비함    

<br>

```
CPU가 요청한 데이터가 캐시에 있으면 cache hit
캐시에 없으면 cache miss라고 함(DRAM에서 데이터를 가져옴)
```

<br>

## 3. 캐시 미스 3가지
1. cold miss/Compulsory miss
해당 메모리 주소를 처음 불러서 나는 미스
없으니 주기억장치에서 데이터 불러와 캐시에 저장함

<br>

2. confilct miss
캐시 메모리에 A데이터 B데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당되어서 나는 캐시 미스(주소할당의 문제).
캐시 메모리가 작아서 발생하는 문제라고 함
해결책은 fully associate(여러개의 캐시 앤트리를 한 세트로 포함시키는 것)로 바꾸면 된다고 함

<br>

3. capcity miss
캐시 메모리의 공간이 부족해서 나는 미스(저장 공간의 문제)
케시 크기를 키워서 해결할 수 있으나, 그러면 접근 속도가 느려지고, 파워를 많이 먹는다는 단점이 있음

<br>

## 4. 구조 및 작동 방식
1. Direct Mapped Cache
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/0d718762-7dad-47a4-a050-f1633c13c03a)   
가장 기본 구조, DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식.   
장점 : 가장 빠름
단점 : confilct miss 발생하는 것

<br>

구성   
- 가장 기본 캐시 배치 정책
- DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식.
- 그림처럼 메모리 공간은 32개, 케시메모리 공간은 8개임. 32:8 = 4:1
- 캐시 메모리 1 주소당 DRAM 4개 주소 할당
- 00001, 01001, 10001, 11001 -> 001
- index field : 001
- tag field : 00, 01, 10, 11
- tag와 index field 뒤에 데이터를 저장하는 data field가 있음

<br>

작동 방식   
1. 캐시 메모리 비어있는 상태. CPU가 메인 메모리의 00001주소의 데이터를 두번 연속 읽은 상황
2. CPU는 캐시메모리 주소 001인 곳에 데이터 있는지 여부 확인함. 비어잇니 캐시미스 발생(Compulsory miss)
3. 일단 CPU는 직접 메인 메모리 00001주소를 참조해서 데이터를 읽음
4. 다시 사용될 수 있으니깐 케시메모리 001주소에 00tag bit와 메인메모리 00001주소에 해당하는 데이터를 저장함
5. 두번째로 CPU가 메인 메모리의 00001주소의 데이터를 읽으려함
6. 캐시 메모리 접근 했는데 데이터가 있음
7. 데이터가 CPU가 요구하는 주소 데이터와 일치한치 tag bit를 검사함
8. 일치하니깐 캐시 메모리에 저장된 데이터를 가져옴

<br>

충돌 예시      
00001와 01001주소 데이터를 동시에 읽어야하는 상황에서 충돌 발생함   

<br>

2. Fully Associative Cache   
비어 있는 캐시 메모리가 있으면, 거기에 주소 저장하는 방식   
장점 : 저장하는 건 쉬움. 빈칸 있으면 거기에 주소 저장하면 되거든    
단점 : 그걸 찾는게 어려움.   

<br>

조건이나 규칙이 없어서, 특정 캐시 set안에 있는 모든 블록을 불러와서, 원하는 데이터가 있는지 검색해야 함.   
그래서 CAM이라는 특수 메모리 구조를 사용하는 대안이 있는데, 가겨이 배우 비쌈    

<br>

3. set Associative Cache
Direct + Fully 방식임   
행과 열이 있음. 특정 행을 지정하고, 그 행 안에 어떤 열이든 비어있을때 저장하는 방식
Direct에 비해 검색 속도는 느린데 저장은 빠름. 그리고 Fully에 비해 저장이 느린데 검색이 빠른 중간형임
> 실제 위 2개 보단 낫데

<br>

## 5. 면접질문
```
Q. 캐시 메모리에 대해 설명해보세요

Q. 캐시 원리에 대해 설명해보세요
```
