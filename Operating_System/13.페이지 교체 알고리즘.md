# 페이지 교체 알고리즘
---
## 페이지 교체란
- 가상 메모모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둠   
- 근데 필요한 페이지만 올려도 메모리가 full상태가 될 수 있고, 올라온 페이지 모두 사용중일 수 있음   
- 그때, 추가로 페이지를 쓰기 위해서 페이지 교체가 일어남.   
  - 페이지 교체 : 올라와있는 페이지와 추가하고싶은 페이지를 swap하는 방법   
  - 즉, 올라와있는 페이지를 out하고, out해서 생긴 빈 프레임에, 필요한 페이지를 in 하는 방법임
  - 이때 어떤 페이지를 out할지 생각해야함(out된 페이지 = victim 페이지)
  - swap당한 victim 페이지가 만일 자주 사용되는 페이지만, 계속 swap(페이지 교체)를 해줘야해서 **오버해드** 발생할 수 있음
  - 그래서 어떤 기준으로 victim 페이지를 선정하는냐에 따라 방법이 여러가지임

<br>

## page reference string 
- CPU는 논리주소를 통해 물리주소를 요구함(데이터에 접근하려고)
- 메인메모리에 올라온 주소들은 페이지 단위로 가져오기에 페이지 번호가 연속되어 나타나면 페이지 결함이 발생하지 않음
- 따라서 CPU의 주소요구에 따라 페이지 결함이 일어나지 않은 부분을 생략하여 표시하는 방법을 의미함
- 무슨말인지 모르겠음

<br>

## victim 페이지 선정 방법 3가지
---
### 1. FIFO 알고리즘
- First-in First-out
- 먼저 올라온 페이지를 먼저 보냄
- victim page : 가장 먼저 메모리에 올라온 페이지
- 가장 간단한 방법이라 구현이 쉬움
- 초기화 코드 : 처음 프로세스 실행될때 최초 초기화 시키는 역할만 진행하고, 다른 역할은 수행하지 않아서, 메인 메모리에서 빼도 괜찮음
- 하지만 처음 프로세스 실행시 무조건 필요한 코드라서, 초기화 시켜준 후 가장 먼저 내보내는 FIFO가 적합함

<br>

### 2. OPT 알고리즘
- 가장 오랫동안 사용되지 않을거라 추측하고 페이지를 선정하는 최적화 알고리즘임
- FIFO 알고리즘에 비해 페이지 교체 횟수를 많이 감소시킬 수 있음
- 근데 실질적으로 페이지가 앞으로 사용되지 않을거란 보장이 없어서 수행하기 어려운 알고리즘임

<br>

### 3. LRU 알고리즘
- Least-Recently-Used
- 사용안한지 가장 오래된 페이지를 선정함
- 최근에 사용하지 않았거나 나중에 사용하지 않을거란 생각에서 나온 아이디어임
- OPT경우 미래 예측이지만, LRU경우 과거를 보고 판단한거라 실질적으로 사용가능한 알고리즘임
- 실제로 최근에 사용하지 않는 페이지는 앞으로 사용하지 않을 확률이 높음
- OPT보다 페이지 교체 횟수가 더 일어날 순 있음. 근데 실제로 사용할 수 있는 페이지 교체 알고리즘 중에서 가장 최적인 방법임

<br>

## 교체 방식
---
### global 교체
```
메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식
```
### local 교체
```
메모리 상의 자기 프로세스 페이지에서만 교체하는 방식
```

<br>

- 다중 프로그래밍의 경우, 메인 메모리에 다양한 프로세스가 동시에 올라가기도 함
- 이때 다양한 프로세스의 페이지가 메모리에 존재함
- 페이지 교체 할때, 다양한 페이지 교체 알고리즘을 활용해서 victim 페이지를 선정하는데, 이때 global로 교체할지 local로 교체할지 에 따라 또 다르다
- 실제로 전체중에서 victim을 선정하는 global이 더 효율적임. 이유는 local 방식으로 각 프로세스의 victim 페이지를 선정해서 비교해야하므로 진행할땐 비효율적이라 함


<br>
<br>
