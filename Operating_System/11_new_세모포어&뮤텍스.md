# 세마포어 & 뮤텍스
---
- 공유된 자원에 여러 프로세스가 동시 접근하면 무제 발생함
- 이때 공유된 자원 데이터는 한번에 하나의 프로세스만 접근하도록 제한두는 방법이 세마포어와 뮤텍스임

<br>

## 임계구역(Critical Section)
- 여러 프로세스가 데이터를 공유하여 수행할때, 각 프로세스에서 공유된 데이터를 접근하는 프로그램 코드 부분을 의미함
- 공유데이터를 여러 프로세스가 동시에 접근할때 잘못된 결과를 만들 수 있어서, 한 프로세스가 임계구역(공유데이터를 사용하는 코드)을 수행할때 다른 프로세스가 접근 못하도록 해야함

<br>

## 세마포어 (Semaphore)
- 멀티프로그래밍 환경에서 공유 자원에 접근을 제한하는 방법 중 하나
- P : 임계 구역에 들어가기 전에 수행
  - 프로세스 진입 여부를 자원개수를 통해 결정함
  - 자원 개수가 충분하면 프로세스는 해당 임계구역을 진입함
  - 그 전에 자원 개수로 진입여부를 파악하는 파트 인듯
- V : 임계 구역에서 나올 때 수행 (자원을 반납하고 대기 중인 프로세스를 깨우는 신호)

<br>

##  Block - Wakeup
### Block(P)
- 커널은 block을 호출한 프로세스를 지연함
- 프로세스의 PCB(process Control block)을 세마퓨어에 대한 wait queue에 넣음
### Wakeup(V)
- block된 프로세스 P를 깨움
- 이 프로세스의 PCB를 ready queue에 옮김
```cpp
procedure P(S)      //최초 S값은 1
  while S=0 do wait  // S=0이면 1이될때까지 대기
  s:=s-1            // s를 0으로 만들어 다른 프로세스가 접근못하게 함
end P

--- 임계구역 ---

procedure V(S)  // 현재 상태 s=0임
  S:=S+1        // s=1 값 복구하고 다른 프로세스 접근가능 하도록 함
end V
```

<br>

### 동작 원리
1. 먼저 도착한 프로세스A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감
2. 그 뒤 도착한 프로세스B가 P(S)를 실행하면 S=0이라서 대기상태
3. A가 임계구역 수행마치면 V(S)를 실행하면 S=1로 복구됨
4. B는 다시 P(S)에서 while문 빠져나와서, 임계구역으로 들어갈 수 있음

<br>

### 주의점
- P와 V은 서로 독립적이라서 잘못 사용되는 경우 문제 발생함
- p : 현재 프로세스가 임계 구역에서 빠져나갈 수 없게 됨. 다른 프로세스들은 임계구역에 들어올 수 없어서 교착상태(데드락) 발생함
- v : 2개 이상의 프로세스가 동시에 임계구역에 들어갈 수 있을때 상호 배체(Mutual Exclusion)를 보장할 수 없음


<br>
<br>
<br>

## 뮤텍스 
- 임계구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
- 상호 배제(Mutual Exclusion)의 약자
- 해당 접근을 조율하기 위해 lock, unlock을 사용함
- lock : 현재 임계구역에 들어갈 권한을 얻음(만약 다른프로세스 혹은 스레드가 임계구역을 수행중이면, 종료때까지 대기함 P와 유사한 개념)
- unlock : 현재 임계구역을 모도 사용했음을 알림(대기 중인 프로세스 혹은 스레드가 임계 구역에 진입할 수 있음, V와 유사)
- 뮤텍스 상태 0과 1은 이진 세마포어라고 부르기도 함

<br>

## 뮤텍스 알고리즘
1. 데커 알고리즘
- flag과 turn변수를 통해 임계 구역에 들어갈 프로세스 혹은 스레드를 결정하는 방식
- flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
- turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수
```cpp
while (true){
  flag[i] = true;      // 프로세스 i가 임계구역 진입 시도함
  while (flag[j]) {    // 프로세스 j가 현재 임계구역에 있는지 확인함
    if(turn==j){        // j가 임계구역 사용중이면
      flag[i]=false;    // 프로세스 i 진입 취소
      while(turn==j);  // turn이 j에서 변경될때까지 대기
      flag[i]=ture;    // j turn 끝나면 다시 진입 시도함
    }
  }
}
```

<br>

2. 피터슨 알고리즘
- 데커와 유사, 상대방 프로세스 혹은 스레드에게 진입 기회를 양보하는 함
```cpp
while (true){
  flag[i] = true;            // 프로세스 i가 임계구역 진입시도함
  turn = j;                  // 다른 프로세스에게 진입 기회를 양보함
  while(flag[j]&&turn==j){   // 다른 프로세스가 진입시도하면 대기함
  }
}

// ----임계구역----
flag[i] = false;            // flag값을 false로 바꿔 임계구역 사용 완료를 알림
```

<br>

3. 제과점 알고리즘
- 여러 프로세스 혹은 스레드에 대한 처리가 가능한 알고리즘
- 가장 작은 수의 번호표를 가진 프로세스가 임계구역에 진입함
```cpp
while(ture){
  isReady[i] = true;                  //  번호표 받을 준비함
  number[i] = max(number[0~n-1])+1;   //  현재 실행 중인 프로세스 중에 가장 큰 번호를 배정받음
  isReady[i] = false;                 // 번호표 수령 완료함

  for(j=0;j<n;j++){                  // 모든 프로세스 번호표 비교함
    while(isReady[j]);                // 비교 프로세스 번호표 받을때까지 대기함
    while(number[j]&&number[j]<number[i]&&j<i);
      // 프로세스 j가 번호표가지고 있어야함
      // 프로세스 j 의 번호표 < 프로세스 i의 번호표
      // 대기 중인 프로세스 중에서 번호표가 가장 작은 것을 찾음
  }
}
```

<br>
<br>
<br>
