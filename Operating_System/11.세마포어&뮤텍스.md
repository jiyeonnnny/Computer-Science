# 세마포어(Semaphore) & 뮤텍스(Mutex)
---
- 공유된 자원에 여러 프로세스가 동시 접근할때 문제가 발생할 수 있음
- 세마포어
  - 이때 공유된 자원의 데이터는 한번에 하나의 프로세스만 접근하도록 제한을 둠
  - 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법
 
<br>
 
### 임계구역(critical section)
- 여러 프로세스가 데이터 공유하며 수행될때, 각 프로세스에서 공유데이터를 접근하는 프로그램 코드 부분을 의미함
- 공유 데이터를 여러 프로세스가 동시 접근할때 잘못될 수 있으니, 한 프로세스가 임계구역을 수행할때 다른 프로세스가 접근못하도록 해야함

<br>

### 세마포어
- P : 임계구역을 들어가기전에 수행(프로세스 진입 여부를 자원개수로 결정함 =)
- V : 임계구역에서 나올때 수행 (자원 반납 알림, 대기중인 프로세스를 깨우는 신호)
- 이를 통해, 한 프로세스가 P 혹은 V를 수행하고 있는 동안, 프로세스가 인터럽트 당하지 않게 됨
- P와 V를 사용해서 임계 구역에 대한 상호배제 구현이 가능해짐

```cpp
procedure P(S)      //최초 S값은 1
  while S=0 do wait  // S=0이면 1이될때까지 대기
  s:=s-1            // s를 0으로 만들어 다른 프로세스가 접근못하게 함
end P

--- 임계구역 ---

procedure V(S)  // 현재 상태 s=0임
  S:=S+1        // s=1 값 복구하고 다른 프로세스 접근가능 하도록 함
end V
```
#### 동작 원리
1. 먼저 도착한 프로세스A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감
2. 그 뒤 도착한 프로세스B가 P(S)를 실행하면 S=0이라서 대기상태
3. A가 임계구역 수행마치면 V(S)를 실행하면 S=1로 복구됨
4. B는 다시 P(S)에서 while문 빠져나와서, 임계구역으로 들어갈 수 있음

<br>

#### 주의점
- P와 V은 서로 독립적이라서 잘못 사용되는 경우 문제 발생함
- p : 현재 프로세스가 임계 구역에서 빠져나갈 수 없게 됨. 다른 프로세스들은 임계구역에 들어올 수 없어서 교착상태(데드락) 발생함
- v : 2개 이상의 프로세스가 동시에 임계구역에 들어갈 수 있을때 상호 배체(Mutual Exclusion)를 보장할 수 없음

<br>
<br>
<br>

### 뮤텍스
- 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되는 기술
- 상호배체(Mutual Exclusion)의 약자
- 해당 접근을 조율하기 위해 lock/unlock 사용
  - lock : 현재 임계구역에 들어갈 권한을 얻어옴(만약 다른 프로세스/스레드가 임계구역 수행 중이면 종료까지 대기함)
  - unlock : 현재 임계구역을 모두 사용했음을 알림(대기 중인 다른 프로세스/스레드가 임계구역에 진입할 수 있음)
 
- 뮤텍스 상태 0,1로 이진 세마포어라고 부름

<br>

### 뮤텍스 알고리즘
1. 데커 알고리즘
- flag과 turn변수를 통해 임계 구역에 들어갈 프로세스 혹은 스레드를 결정하는 방식
- flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
- turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수
```cpp
while (true){
  flag[i] = true;      // 프로세스 i가 임계구역 진입 시도함
  while (flag[j]) {    // 프로세스 j가 현재 임계구역에 있는지 확인함
    if(turn==j){        // j가 임계구역 사용중이면
      flag[i]=false;    // 프로세스 i 진입 취소
      while(turn==j);  // turn이 j에서 변경될때까지 대기
      flag[i]=ture;    // j turn 끝나면 다시 진입 시도함
    }
  }
}
```

<br>

2. 피터슨 알고리즘
- 데커와 유사, 상대방 프로세스 혹은 스레드에게 진입 기회를 양보하는 함
```cpp
while (true){
  flag[i] = true;            // 프로세스 i가 임계구역 진입시도함
  turn = j;                  // 다른 프로세스에게 진입 기회를 양보함
  while(flag[j]&&turn==j){   // 다른 프로세스가 진입시도하면 대기함
  }
}

// ----임계구역----
flag[i] = false;            // flag값을 false로 바꿔 임계구역 사용 완료를 알림
```

<br>

3. 제과점 알고리즘
- 여러 프로세스 혹은 스레드에 대한 처리가 가능한 알고리즘
- 가장 작은 수의 번호표를 가진 프로세스가 임계구역에 진입함
```cpp
while(ture){
  isReady[i] = true;                  //  번호표 받을 준비함
  number[i] = max(number[0~n-1])+1;   //  현재 실행 중인 프로세스 중에 가장 큰 번호를 배정받음
  isReady[i] = false;                 // 번호표 수령 완료함

  for(j=0;j<n;j++){                  // 모든 프로세스 번호표 비교함
    while(isReady[j]);                // 비교 프로세스 번호표 받을때까지 대기함
    while(number[j]&&number[j]<number[i]&&j<i);
      // 프로세스 j가 번호표가지고 있어야함
      // 프로세스 j 의 번호표 < 프로세스 i의 번호표
      // 대기 중인 프로세스 중에서 번호표가 가장 작은 것을 찾음
  }
}
```
