# TCP

### TCP란
- OSI 7계층 중 4계층(전송)에 해당
- 전송계층 : 데이터를 송신 수신함
- sender - recevier
- TCP(reliable network) / UDP(unreliable network)
- TCP는 network congestion avoidance algorithm을 사용함

### reliable network
- 직역 : 믿을수있는 네트워크
- 데이터 송수신에 있어서, 손실 혹은 그 외 문제들이 일어나지 않고, 잘 전달되도록 **보장**된 프로토콜임

### 전송할때(transport), 발생할 수 있는 4가지 문제점
- 손실: 패킷이 손실될 수 있음
- 순서 바뀜 : 패킷 순서가 바뀔 수 있음
- congestion : 네트워크가 혼잡해질 수 있음
- overload : receiver가 과부화될 수 있음

### 흐름제어/혼잡제어
- 흐름제어
  - 송수신의 데이터 처리 속도차이를 해결하기 위한 기법
  - flow control은 receiver가 패킷을 지나치게 많이 받지 않도록 조절함
  - 기본적으로 receiver가 sender에게 현재 자신의 상태를 피드백함
  - '아 너무 많아 천천히 보내'
- 혼잡제어 : sender의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하는 기법
- sender data보냄 - 네트워크 데이터 처리 - receiver data받음

### 전송의 전체 과정
- application층에서 sender application layer가 socket에 data를 씀
- transport layer에서 data를 segment에 감싸서, network계층에 넘겨줌
- data는 더 아랫단에서 receiving node로 전송됨. 이때 sender의 send buffer에 data를 저장하고 receiver은 receive buffer에 data를 저장함
- receiver의 application이 준비되면 이 buffer에 있는 것을 읽기 시작함
- 즉, flow control핵심은 receiver buffer가 넘치지 않게 하는 것임
- 즉, receiver은 RWND(Receiver Window)가 receiver buffer 상태(남은 공간)를 알려줌

## 흐름 제어(flow control)
### 흐름제어란
- sender - receiver 사이 데이터 처리 속도 차이로 인한 receiver buffer에 너무 많은 packet이 쌓이지 않도록, 제어하는 것을 의미함
- 해결하기 위해 receiver의 buffer 상태를 sender에게 알림(feedback)

### 해겹방법
1. stop and wait
- 매번 전송한 패킷이 잘 도착했다는 응답을 받아야 다음패킷을 보냄

2. sliding window(go back N ARQ)
- receiver의 window 크기만큼 sender에서 확인응답없이 세그먼트를 전송함. 그렇게 흐름제어함
- 전송은 되는데, acked를 받지 못한 byte의 숫자를 파악하기 위해 사용하는 프로토콜임
- LastByteSent = LastByteAcked = ReceiverWindowAdvertised
- (마지막에 보낸 바이트 - 마지막 확인 바이트 = 남은 공간 == 현재 공중에 떠있는 패킷 수)

3. 동작방식
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/3df17715-76fb-4ce6-91a6-d0c04290d04c)
- window size에 포함되는 모든 패킷은 하나씩 전송함
- 그 패킷 전달 여부를 확인하면 윈도우를 옆으로 옮겨서 그 다음 패킷을 전송함

4. window
- TCP/IP 프로토콜 사용하는 호스트들은 sender의 window와 receiver의 window를 가지고 있음
- 호스트들은 실제 데이터를 보내기 전에 3 way handshake를 통해서 sender의 windwo size를 receiver의 window size에 맞춰줌

5. 세부구조
   1. 송신버퍼
   ![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/5652f2a4-9d7d-44bc-890d-cfa0ed85f178)
    - 이전 바이트는 이미 전송됨
    - 200~202 바이트는 receiver에게 보내고 확인응답을 받음
    - 203~211 바이트는 receiver에게 보낼 예정(아직 안보냄)
   2. 수신 윈도우
   ![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/eb23f088-59f2-4325-8caa-9c8077d7f391)
   3. 송신 윈도우  
   ![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/e6269d3e-db73-4268-986b-ba9a99d41206)
   - sender window size < receiver window size 로 설정하면 flow control이 가능함
   4. 송신 윈도우 이동
   ![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/2af64723-7fa9-4996-a82d-6f441d138e00)
   - before : 203~204전송하면 receiver에서 203 확인응답을 보내고, sender은 이걸 받음. 이때 receiver window는 after 사진과 같이 범위 이동함
   - after : 205~209가 전송 가능한 상태
   5. selected repeat

## 혼잡 제어
### 혼잡제어란
- congestion control
- sender data는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됨
- 만약 한 라우터에 데이터가 몰리면, 자신에게 온 데이터를 모두 처리할 수 없음
- 이럴땐, 호스트들은 또 다시 재전송을 함. 그럼 혼잡 가중 됨. 그럼 오버플로우 or 데이터 손실 발생함.
- 그래서 이런 네트워크 혼잡을 피하기 위해, sender의 send 속도를 강제로 줄임 == 혼잡 제어

- 네트워크 내에 패킷 수가 과도히 증가하면 혼잡이라 함
- 이 혼잡 현상을 방지 혹은 제거하기 하기 위해 혼잡제어함
- 흐름 제어는 송수신 사이 전송 속도 차이를 완화하는 거면, 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다룸

- 호스트 : 걍 각각의 컴퓨터 기기임. 때론 클라이언트가 될 수 있고 때론 서버가 될 수 있음
- 라우터 : 데이터 전달 게이트웨이. 걍 데이터가 거쳐 지나가는 통로 같은 거임. 한 라우터에 여러게 호스트가 연결되어 있음.


### 해결방법
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/e565e598-f1df-4dfa-a3b3-91840c288e1d)
1. AIMD
- Additive increase / multiplicative decrease
- 처음에 패킷을 하나씩 보내고, 이게 문제없이 도착하면 window크기를 1씩 증가시키며 전송하는 방법임
- 패킷 전송에 실패하거나 일정시간 넘으면 패킷 보내는 **속도를 절반으로 줄임**
- 동일한 방식으로, 여러 호스트가 한 라우터를 공유, 한 네트워크를 공유하면, 나중에 진입하는 호스트는 처음에 불리하지만(속도가 느리니깐), 시간이 흐를 수록 평형 상태로 수렴함
- 근데 문제점이 있음. 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식임

2. slow start
- AIMD 방식이 네트워크 수용량 측면에선 효울적임. 근데 처음에 전송 속도를 올리는데 시간이 오래 걸림
- slow start 방식은 SIMD와 마찬가지로 ACK패킷마다 window size를 1씩 늘려줌. 한주기가 지나면 window size는 2배가 됨
- 전송 속도는 AIMD에 비해 **지수함수 꼴로 증가**함. 대신 혼잡 상황 발생시 window size는 **1씩 떨어짐**
- 첨에 네트워크 수용량을 예상할 수 있는 정보는 없어서, 한번 혼잡 현상이 발생하면 네트워크 수용량을 어느정도 예상할 수 있음. 한번은 혼잡현상을 겪어야 네트워크 수용량을 예상해서 혼잡제어를 할 수 있음. 그전엔 한번은 혼잡을 겪어야함
- 그래서 혼잡 발생하면 window size가 절반까지 -1씩 줄임. 그 후엔 다시 지수 꼴로 증가하고 이후부턴 완만하게 **1씩 증가함**

3. fast retransmit
- TCP 혼잡제어 기능 중 하나, 빠른 재전송
- 패킷 receiver 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ack 패킷(확인 패킷)을 보내게 됨
- 

4. fast recovery
