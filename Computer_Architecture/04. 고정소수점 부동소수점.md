## 들어가기 전
```
컴퓨터에서 실수를 표현하기 위해, 모든 메모리를 다 사용할 수 없으므로, 시술표현할때 사용할 비트수를 정함

데이터 분석 프로젝트를 진행하며 Numpy를 사용할때, float16, float32, float64와 같은 수 표현 체계가 있음
넘파이에서 실수를 표현할때 몇비트사용할지, 사용자가 임의로 정해둔 것

예를 들어 float32는 실수를 32비트를 활용해 표현함. 그리고 당연하게도 더 많은 비트를 쓸수록 더 큰 실수 표현이 가능하지만
그만큼 메모리를 비효율적으로 사용할 가능성도 큼

그렇기에 컴퓨터가 실수를 다루는 2가지 방법 고정소수점, 부동소수점이 있음.
```

<br>

# 고정 소수점
## 고정소수점 원리
```
- 고정소수점은 정수를 표현하는 비트, 소수 표현하는 비트(고정)을 미리 정하고 해당 비트만 활용하여 실수를 표현함
- 처음 1비트는 부호
- 다음 15비트는 정수부
- 다음 16비트는 소수부
- 정수부/소수부의 경계를 소수점의 위치라고 생각하고, 2진수로 변환된 수를 그대로 넣으면 됨
- 마지막으로 남는 자리는 모두 0으로 채우면 됨.
- 아래 예시) 10진수 7.625 32비트 고정소수점으로 표현
```
[고정소수점 구조]   
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/b1ead322-cd7a-4ea3-8e64-62e43f97bb4e)
[10진수 -> 2진수]    
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/99ba31c7-2a0d-4599-af63-ffcb82a59964)    
[32비트 고정소수점]   
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/b19f0722-56e1-48ba-bfb7-d03d44d12ad6)   

<br>

## 고정소수점 장단점
```
[장점]
고정소수점 방식은 부동소수점 방식에 비해 실수를 표현하는 방법이 단순하고 속도가 빠름

[단점]
- 정수부,소수부에 사용할 비트가 고정되어 있어서 큰 실수를 표현하기 어려움
- 이유 : 정수부 15비트, 소수부 16비트만 사용가능해서
```

<br>
<br>
<br>

# 부동 소수점
## 부동 소수점 원리
```
- 부동 : 떠다닌다, 부유하다의 뜻으로, 소수점을 옮겨서 실수를 표현하는 방법
- 부동소수점은 고정소수점 방식과 비트를 사용하는 체계가 다름.
  그리고 부동소수점은 이를 표현하는 다양한 체계가 있는데, 일반적으로 가장 널리 쓰이는 IEEE 754가 있음.
- IEEE 754 기반의 상세 설명
- 2진수를 정규화
  - 처음 1비트 부호비트.
  - 다음 8비트 지수부. 정규화 과정에서 얻은 지수에 bias를 더한 값으로 채움
  - 다음 23비트는 가수부. 소수 부분을 나타내는 부분.
```
[부동소수점 구조]   
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/00fcb5ec-7975-41e1-b718-741c3f0a21b9)   

<br>

## 부동소수점 원리에 대한 자세한 설명
1. 정규화
```
- 컴퓨터 공학에서 정규화 개념 : 이진수를 1.XXX * 2^N 형태로 나타낸 것
- 7.625 10진수를 2진수로 변환하면 111.101
- 111.101정규화하면 1.11101*2^2로 표현가능
- 지수는 2라는 뜻
```

<br>

2. Exponent & Bias
```
- 지수부에 2를 바로 채우는 것이 아니라, IEEE 754표준에서는 32비트로 실수를 표현할때 127(10진수)라는 bias를 더한 값으로 채움
- 129(127+2)를 2진수로 변환한 값 10000001.
- 이유 : 지수가 음수일 경우를 대처하기 위해서임
- 예 : 0.000101이라는 이진수를 정규화하면 1.01*2^-4라는 값을 얻게 됨
- 여기서 지수는 -4가 나옴
```
```
음수 표현
1. 가장 간단한 아이디어는 전체수가 양수인지 음수인지, 부호비트로 표현. 이경우 표현가능한 수의 범위가 작아짐.
2. IEEE 754 표준에서는 8비트로 음수양수 모두를 표현하기 위한 하나의 장치로 bias라는 값을 설정함. 이를 통해 exponent 부분은 항상 unsigned값만 가지게 셋팅 하게 됨
3. 참고로 0과 255는 각각 0과 무한대 등을 나타내기 위해, 특별히 할당된 숫자라서 정규화가 적용되지 않음
```

<br>

3. 가수부(mantassia)
```
가수부는 고정소수점의 소수부와 같은 역할.
정규화 결과의 소수을 가수부자리에 그대로 넣고, 남는 자리 0으로 채움
```

<br>

4. 예시 - 7.625(10진수) 부동소수점으로 표현   
![image](https://github.com/jiyeonnnny/Computer-Science/assets/139419091/1bec5889-b39b-4438-8df0-4ed00fdf9b77)   

<br>

## 부동소수점의 장단점
```
[장점]
- 부동소수점은 고정소수점에 비해 더 큰 실수 표현 가능
- 부동소수점에서 무한대 수를 표현하는 255를 제외하고 실질적으로 가장 큰 숫자는 254.
- 254에는 bias 127이 더해져 있음. 그래서 정규화 결과로 가질 수 있는 가장 큰 지수는 127임.
- 따라서 32비트 부동소수점에서 가질 수 있는 가장 큰 수의 정규화 결과는 1.XXX*2^127 형태임.
- 정규화 이전 값을 떠올려보면 고정소수점에 비해 정수 자리에 훨씬 더 많은 비트를 할당할 수 있음(15 -> 127)

[단점]
- 실수연산이 부정확할 수 있음
- 예를 들어, 0.3(10진수)를 2진수로 변환하면 0.0100110011001...처럼 특성수가 무한 반복됨.
- 따라서 컴퓨터가 실수부분을 표현할 수 있는 비트수를 다 써서 근사치로 표현하게 됨.
```

<br>
